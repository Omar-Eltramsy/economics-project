// Base API URLs
const API_BASE_URL = '/api'; // Change this to match your ESP32 API endpoint

// API Endpoints
const API_ENDPOINTS = {
  remoteControl: `${API_BASE_URL}/remote_control`,
  load1: {
    status: `${API_BASE_URL}/load1/status`,
    control: `${API_BASE_URL}/load1/control`,
    power: `${API_BASE_URL}/load1/power`
  },
  load2: {
    status: `${API_BASE_URL}/load2/status`,
    control: `${API_BASE_URL}/load2/control`,
    power: `${API_BASE_URL}/load2/power`
  },
  load3: {
    status: `${API_BASE_URL}/load3/status`,
    control: `${API_BASE_URL}/load3/control`,
    power: `${API_BASE_URL}/load3/power`
  },
  system: {
    status: `${API_BASE_URL}/system/status`
  }
};

// State management
const appState = {
  remoteControl: false,
  loads: {
    1: { status: false, power: 0 },
    2: { status: false, power: 0 },
    3: { status: false, power: 0 }
  },
  connection: {
    status: true,
    lastUpdate: Date.now()
  }
};

// DOM Elements
const elements = {
  remoteToggle: document.getElementById('remote-toggle'),
  remoteStatus: document.getElementById('remote-status'),
  totalPower: document.getElementById('total-power'),
  activeLoads: document.getElementById('active-loads'),
  connectionIcon: document.getElementById('connection-icon'),
  connectionText: document.getElementById('connection-text'),
  themeToggle: document.getElementById('theme-toggle-btn'),
  loads: {
    1: {
      panel: document.getElementById('load1-panel'),
      power: document.getElementById('load1-power'),
      status: document.getElementById('load1-status'),
      indicator: document.getElementById('load1-indicator').querySelector('.indicator-dot'),
      onBtn: document.getElementById('load1-on'),
      offBtn: document.getElementById('load1-off')
    },
    2: {
      panel: document.getElementById('load2-panel'),
      power: document.getElementById('load2-power'),
      status: document.getElementById('load2-status'),
      indicator: document.getElementById('load2-indicator').querySelector('.indicator-dot'),
      onBtn: document.getElementById('load2-on'),
      offBtn: document.getElementById('load2-off')
    },
    3: {
      panel: document.getElementById('load3-panel'),
      power: document.getElementById('load3-power'),
      status: document.getElementById('load3-status'),
      indicator: document.getElementById('load3-indicator').querySelector('.indicator-dot'),
      onBtn: document.getElementById('load3-on'),
      offBtn: document.getElementById('load3-off')
    }
  }
};

// API Service
const apiService = {
  /**
   * Perform a fetch request with error handling
   * @param {string} url - The API endpoint URL
   * @param {Object} options - Fetch options
   * @returns {Promise} - The fetch promise
   */
  async fetch(url, options = {}) {
    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
      }

      appState.connection.status = true;
      appState.connection.lastUpdate = Date.now();
      uiController.updateConnectionStatus(true);

      return await response.json();
    } catch (error) {
      console.error('API Request Failed:', error);
      appState.connection.status = false;
      uiController.updateConnectionStatus(false);
      return null;
    }
  },

  /**
   * Set remote control mode
   * @param {boolean} enabled - Whether to enable remote control
   */
  async setRemoteControl(enabled) {
    const result = await this.fetch(API_ENDPOINTS.remoteControl, {
      method: 'POST',
      body: JSON.stringify({ value: enabled ? 1 : 0 })
    });

    if (result) {
      appState.remoteControl = enabled;
      uiController.updateRemoteControlUI(enabled);
      loadController.updateButtonStates();
    }

    return result;
  },

  /**
   * Control a specific load
   * @param {number} loadId - The load ID (1, 2, or 3)
   * @param {boolean} on - Whether to turn the load on or off
   */
  async controlLoad(loadId, on) {
    if (loadId < 1 || loadId > 3) return null;

    const endpoint = API_ENDPOINTS[`load${loadId}`].control;
    const result = await this.fetch(endpoint, {
      method: 'POST',
      body: JSON.stringify({ value: on ? 1 : 0 })
    });

    if (result) {
      appState.loads[loadId].status = on;
      uiController.updateLoadStatus(loadId, on);
      dataController.updateSystemStats();
    }

    return result;
  },

  /**
   * Fetch status for a specific load
   * @param {number} loadId - The load ID (1, 2, or 3)
   */
  async fetchLoadStatus(loadId) {
    if (loadId < 1 || loadId > 3) return null;

    const endpoint = API_ENDPOINTS[`load${loadId}`].status;
    const result = await this.fetch(endpoint);

    if (result && result.hasOwnProperty('status')) {
      const isOn = Boolean(result.status);
      appState.loads[loadId].status = isOn;
      uiController.updateLoadStatus(loadId, isOn);
    }

    return result;
  },

  /**
   * Fetch power consumption for a specific load
   * @param {number} loadId - The load ID (1, 2, or 3)
   */
  async fetchLoadPower(loadId) {
    if (loadId < 1 || loadId > 3) return null;

    const endpoint = API_ENDPOINTS[`load${loadId}`].power;
    const result = await this.fetch(endpoint);

    if (result && result.hasOwnProperty('power')) {
      appState.loads[loadId].power = result.power;
      uiController.updateLoadPower(loadId, result.power);
    }

    return result;
  },

  /**
   * Fetch system status
   */
  async fetchSystemStatus() {
    const result = await this.fetch(API_ENDPOINTS.system.status);
    
    if (result) {
      if (result.hasOwnProperty('remote_control')) {
        appState.remoteControl = Boolean(result.remote_control);
        uiController.updateRemoteControlUI(appState.remoteControl);
        loadController.updateButtonStates();
      }

      if (result.hasOwnProperty('loads')) {
        // Update loads if included in response
        for (let i = 1; i <= 3; i++) {
          if (result.loads[i]) {
            if (result.loads[i].hasOwnProperty('status')) {
              appState.loads[i].status = Boolean(result.loads[i].status);
              uiController.updateLoadStatus(i, appState.loads[i].status);
            }
            if (result.loads[i].hasOwnProperty('power')) {
              appState.loads[i].power = result.loads[i].power;
              uiController.updateLoadPower(i, result.loads[i].power);
            }
          }
        }
      }

      dataController.updateSystemStats();
    }

    return result;
  }
};

// UI Controller
const uiController = {
  /**
   * Update the remote control toggle UI
   * @param {boolean} enabled - Whether remote control is enabled
   */
  updateRemoteControlUI(enabled) {
    elements.remoteToggle.checked = enabled;
    elements.remoteStatus.textContent = enabled ? 'Enabled' : 'Disabled';
    elements.remoteStatus.style.color = enabled ? 'var(--success-color)' : 'var(--danger-color)';
  },

  /**
   * Update the load status UI
   * @param {number} loadId - The load ID (1, 2, or 3)
   * @param {boolean} isOn - Whether the load is on
   */
  updateLoadStatus(loadId, isOn) {
    const loadElements = elements.loads[loadId];
    
    // Update status badge
    loadElements.status.textContent = isOn ? 'ON' : 'OFF';
    loadElements.status.classList.remove('on', 'off');
    loadElements.status.classList.add(isOn ? 'on' : 'off');
    
    // Update indicator dot
    loadElements.indicator.classList.remove('on', 'off');
    loadElements.indicator.classList.add(isOn ? 'on' : 'off');
    
    // Add visual feedback
    loadElements.panel.style.borderLeft = isOn 
      ? '4px solid var(--success-color)' 
      : '4px solid var(--grey-color)';

    // Update power display color
    loadElements.power.style.color = isOn 
      ? 'var(--success-color)' 
      : 'var(--dark-color)';
  },

  /**
   * Update the load power UI
   * @param {number} loadId - The load ID (1, 2, or 3)
   * @param {number} power - The power consumption value
   */
  updateLoadPower(loadId, power) {
    elements.loads[loadId].power.textContent = power;
  },

  /**
   * Update connection status UI
   * @param {boolean} connected - Whether system is connected
   */
  updateConnectionStatus(connected) {
    if (connected) {
      elements.connectionIcon.innerHTML = '<i class="fas fa-wifi"></i>';
      elements.connectionIcon.style.color = 'var(--success-color)';
      elements.connectionText.textContent = 'Connected';
      elements.connectionText.style.color = 'var(--success-color)';
      elements.connectionIcon.classList.remove('pulse');
    } else {
      elements.connectionIcon.innerHTML = '<i class="fas fa-wifi-slash"></i>';
      elements.connectionIcon.style.color = 'var(--danger-color)';
      elements.connectionText.textContent = 'Disconnected';
      elements.connectionText.style.color = 'var(--danger-color)';
      elements.connectionIcon.classList.add('pulse');
    }
  },

  /**
   * Show a temporary notification for API operations
   * @param {string} message - The notification message
   * @param {string} type - The notification type ('success', 'error', 'info')
   */
  showNotification(message, type = 'info') {
    // Create notification element if it doesn't exist
    let notification = document.querySelector('.notification');
    if (!notification) {
      notification = document.createElement('div');
      notification.className = 'notification';
      document.body.appendChild(notification);
    }
    
    // Set notification style and content
    const colors = {
      success: 'var(--success-color)',
      error: 'var(--danger-color)',
      info: 'var(--primary-color)'
    };
    
    notification.textContent = message;
    notification.style.backgroundColor = colors[type];
    notification.classList.add('show');
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }
};

// Load Controller
const loadController = {
  /**
   * Update button states based on remote control status
   */
  updateButtonStates() {
    for (let i = 1; i <= 3; i++) {
      elements.loads[i].onBtn.disabled = !appState.remoteControl;
      elements.loads[i].offBtn.disabled = !appState.remoteControl;
    }
  },

  /**
   * Initialize load control buttons
   */
  initializeButtons() {
    for (let i = 1; i <= 3; i++) {
      const loadId = i;
      elements.loads[loadId].onBtn.addEventListener('click', () => {
        if (appState.remoteControl) {
          apiService.controlLoad(loadId, true);
        }
      });
      
      elements.loads[loadId].offBtn.addEventListener('click', () => {
        if (appState.remoteControl) {
          apiService.controlLoad(loadId, false);
        }
      });
    }
  }
};

// Data Controller
const dataController = {
  /**
   * Fetch all data from the API
   */
  async fetchAllData() {
    try {
      // Fetch system status first (might include all data)
      await apiService.fetchSystemStatus();
      
      // Fetch individual load data if needed
      for (let i = 1; i <= 3; i++) {
        await apiService.fetchLoadStatus(i);
        await apiService.fetchLoadPower(i);
      }
      
      this.updateSystemStats();
    } catch (error) {
      console.error('Error fetching data:', error);
      uiController.updateConnectionStatus(false);
    }
  },

  /**
   * Update system statistics display
   */
  updateSystemStats() {
    // Calculate total power
    const totalPower = Object.values(appState.loads).reduce((sum, load) => {
      return sum + (load.status ? load.power : 0);
    }, 0);
    
    // Calculate active loads
    const activeLoads = Object.values(appState.loads).filter(load => load.status).length;
    
    // Update UI
    elements.totalPower.textContent = `${totalPower} W`;
    elements.activeLoads.textContent = `${activeLoads}/3`;
  },

  /**
   * Start polling for data updates
   */
  startDataPolling() {
    // Poll for system status every 5 seconds
    setInterval(() => {
      this.fetchAllData();
    }, 5000);
  }
};

// Theme Controller
const themeController = {
  getCurrentTheme() {
    return localStorage.getItem('theme') || 'light';
  },
  
  setTheme(theme) {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
    
    // Update UI elements if needed
    if (elements.themeToggle) {
      elements.themeToggle.setAttribute('aria-label', 
        theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
    }
  },
  
  toggleTheme() {
    const currentTheme = this.getCurrentTheme();
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    this.setTheme(newTheme);
  },
  
  initTheme() {
    // Set initial theme based on localStorage or system preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      this.setTheme(savedTheme);
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      this.setTheme('dark');
    }
    
    // Listen for system theme changes
    if (window.matchMedia) {
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (!localStorage.getItem('theme')) {
          this.setTheme(e.matches ? 'dark' : 'light');
        }
      });
    }
  }
};

// Event listeners
function setupEventListeners() {
  // Remote control toggle
  elements.remoteToggle.addEventListener('change', (e) => {
    apiService.setRemoteControl(e.target.checked);
  });
  
  // Theme toggle
  elements.themeToggle.addEventListener('click', () => {
    themeController.toggleTheme();
  });
  
  // Handle orientation change for mobile
  window.addEventListener('orientationchange', () => {
    // Small delay to allow layout to settle
    setTimeout(() => {
      updateLayoutForOrientation();
    }, 100);
  });
}

// Update layout for orientation
function updateLayoutForOrientation() {
  const isLandscape = window.innerWidth > window.innerHeight;
  const dashboard = document.querySelector('.dashboard');
  
  if (isLandscape && window.innerWidth < 1024) {
    // Landscape mode on mobile - adjust layout if needed
    dashboard.style.gridTemplateColumns = '1fr 1fr';
  } else {
    // Portrait mode or desktop - use default layout
    dashboard.style.gridTemplateColumns = '';
  }
}

// Initialization
async function initialize() {
  // Initialize theme
  themeController.initTheme();
  
  // Setup event listeners
  setupEventListeners();
  
  // Initialize load control buttons
  loadController.initializeButtons();
  
  // Initial data fetch
  await dataController.fetchAllData();
  
  // Start data polling
  dataController.startDataPolling();
  
  // Update layout for current orientation
  updateLayoutForOrientation();

  // For demo purposes, simulate API responses if needed
  if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    setupMockAPI();
  }
  
  // Add touch-friendly enhancements for mobile
  addTouchEnhancements();
}

// Mock API for local development and testing
function setupMockAPI() {
  console.log('Setting up mock API for local development');
  
  // Override fetch method for mocking
  const originalFetch = apiService.fetch;
  apiService.fetch = async (url, options = {}) => {
    console.log(`Mock API request: ${url}`, options);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Handle different endpoints
    if (url.includes('/remote_control')) {
      // Remote control toggle
      if (options.method === 'POST') {
        const body = JSON.parse(options.body);
        appState.remoteControl = Boolean(body.value);
        return { success: true, remote_control: appState.remoteControl };
      }
    } 
    else if (url.match(/\/load[1-3]\/control/)) {
      // Load control
      if (options.method === 'POST') {
        const loadId = url.match(/load(\d)/)[1];
        const body = JSON.parse(options.body);
        appState.loads[loadId].status = Boolean(body.value);
        return { success: true, status: appState.loads[loadId].status };
      }
    }
    else if (url.match(/\/load[1-3]\/status/)) {
      // Load status
      const loadId = url.match(/load(\d)/)[1];
      return { status: appState.loads[loadId].status ? 1 : 0 };
    }
    else if (url.match(/\/load[1-3]\/power/)) {
      // Load power - generate random values if load is on
      const loadId = url.match(/load(\d)/)[1];
      if (appState.loads[loadId].status) {
        // Simulate fluctuating power when on
        const basePower = loadId === '1' ? 120 : loadId === '2' ? 85 : 150;
        const variation = Math.random() * 20 - 10; // -10 to +10
        appState.loads[loadId].power = Math.round(basePower + variation);
      } else {
        appState.loads[loadId].power = 0;
      }
      return { power: appState.loads[loadId].power };
    }
    else if (url.includes('/system/status')) {
      // System status
      return {
        remote_control: appState.remoteControl ? 1 : 0,
        loads: {
          1: { status: appState.loads[1].status ? 1 : 0, power: appState.loads[1].power },
          2: { status: appState.loads[2].status ? 1 : 0, power: appState.loads[2].power },
          3: { status: appState.loads[3].status ? 1 : 0, power: appState.loads[3].power }
        }
      };
    }
    
    // Default fallback
    return { success: false, error: 'Endpoint not mocked' };
  };
  
  // Add CSS for notifications
  const style = document.createElement('style');
  style.textContent = `
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      z-index: 1000;
      transform: translateY(-100px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
  `;
  document.head.appendChild(style);
  
  // Pre-populate with some data
  setTimeout(() => {
    apiService.controlLoad(1, true);
    setTimeout(() => apiService.controlLoad(3, true), 2000);
  }, 1500);
}

// Add touch-friendly enhancements for mobile devices
function addTouchEnhancements() {
  // Add active state for touch devices
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(button => {
    button.addEventListener('touchstart', function() {
      if (!this.disabled) {
        this.classList.add('touch-active');
      }
    });
    
    button.addEventListener('touchend', function() {
      this.classList.remove('touch-active');
    });
    
    button.addEventListener('touchcancel', function() {
      this.classList.remove('touch-active');
    });
  });
  
  // Add pull-to-refresh functionality
  let touchStartY = 0;
  let touchEndY = 0;
  const minSwipeDistance = 100;
  
  document.addEventListener('touchstart', function(e) {
    touchStartY = e.changedTouches[0].screenY;
  }, { passive: true });
  
  document.addEventListener('touchend', function(e) {
    touchEndY = e.changedTouches[0].screenY;
    handleSwipeGesture();
  }, { passive: true });
  
  function handleSwipeGesture() {
    const distance = touchEndY - touchStartY;
    if (distance > minSwipeDistance && window.scrollY === 0) {
      // Pull down at top of page - refresh data
      showPullToRefreshIndicator();
      dataController.fetchAllData().then(() => {
        hidePullToRefreshIndicator();
      });
    }
  }
  
  function showPullToRefreshIndicator() {
    // Create or show pull-to-refresh indicator
    let indicator = document.querySelector('.pull-refresh-indicator');
    if (!indicator) {
      indicator = document.createElement('div');
      indicator.className = 'pull-refresh-indicator';
      indicator.innerHTML = '<i class="fas fa-sync fa-spin"></i> Refreshing...';
      document.body.appendChild(indicator);
    }
    indicator.classList.add('active');
  }
  
  function hidePullToRefreshIndicator() {
    const indicator = document.querySelector('.pull-refresh-indicator');
    if (indicator) {
      // Add a small delay before hiding
      setTimeout(() => {
        indicator.classList.remove('active');
      }, 500);
    }
  }
  
  // Add pull-to-refresh styles
  const refreshStyle = document.createElement('style');
  refreshStyle.textContent = `
    .pull-refresh-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: var(--primary-color);
      color: white;
      text-align: center;
      padding: 12px;
      transform: translateY(-100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      font-weight: 600;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .pull-refresh-indicator.active {
      transform: translateY(0);
    }
    
    .touch-active {
      transform: scale(0.95);
      opacity: 0.9;
    }
  `;
  document.head.appendChild(refreshStyle);
}

// Initialize the application
document.addEventListener('DOMContentLoaded', initialize);